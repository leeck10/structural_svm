/*
  File autogenerated by gengetopt version 2.20
  generated with the following command:
  C:\MinGW\msys\1.0\local\bin\gengetopt.exe -i ssvm.ggo -u -F ssvm_cmdline 

  The developers of gengetopt consider the fixed text that goes in all
  gengetopt output files to be in the public domain:
  we make no copyright claims on it.
*/

/* If we use autoconf.  */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "getopt.h"

#include "ssvm_cmdline.h"

const char *gengetopt_args_info_purpose = "A command line utility to train/test a Structural SVM (SSVM) model.";

const char *gengetopt_args_info_usage = "Usage: ssvm_tool [OPTIONS]... [FILES]...";

const char *gengetopt_args_info_description = "";

const char *gengetopt_args_info_help[] = {
  "  -h, --help             Print help and exit",
  "  -V, --version          Print version and exit",
  "\nTraining options:",
  "  -c, --cost=FLOAT       set cost of SSVMs  (default=`1')",
  "  -m, --model=STRING     set model file name",
  "  -b, --binary           save/load model in binary format  (default=off)",
  "      --source=STRING    source model file for domain adaptation",
  "      --skip_eval        skip test set evaluation in the middle of training  \n                           (default=off)",
  "      --owps_format      use One Word Per Sentence (OWPS) format  (default=off)",
  "      --hash=INT         use hash feature and set number of predicates  \n                           (default=`0')",
  "  -s, --support          use support feature (default is all feature)  \n                           (default=off)",
  "      --general          general feature mode (feature:value format) (default \n                           is binary feature)  (default=off)",
  "  -r, --random=INT       use random_shuffle in train_data (disabled if use 0)  \n                           (default=`0')",
  "      --train_num=INT    set number of sentence in train_data for training (for \n                           experiments) (disabled if use 0)  (default=`0')",
  "  -v, --verbose          verbose mode  (default=off)",
  "\nStructural SVM options:",
  "  -e, --epsilon=FLOAT    set epsilon (fsmo, fsmo_joint)  (default=`0.01')",
  "      --buf=INT          set the number of new constraints to accumulated \n                           before recomputing the QP (fsmo, pegasos)  \n                           (default=`100')",
  "      --rm_inactive=INT  inactive constraints are removed (iteration) (fsmo, \n                           fsmo_joint)  (default=`50')",
  "      --final_opt        do final optimal check in shrinking (fsmo, fsmo_joint) \n                            (default=off)",
  "      --comment          use comment info in save_slack() (fsmo)  (default=off)",
  "\nPegasos options:",
  "  -i, --iter=INT         iterations for training algorithm (pegasos)  \n                           (default=`100')",
  "      --period=INT       save model periodically (pegasos)  (default=`0')",
  "\nLatent Strucutral SVM options:",
  "      --latent           use CCCP-based Latent SSVM (doesn't support sequence \n                           labeling)  (default=off)",
  "      --latent_SPL       use Self-Paced Learning for Latent SSVM (doesn't \n                           support sequence labeling)  (default=off)",
  "\nJoint Strucutral SVM options:",
  "      --joint            use Joint model (y+z) using modified Latent SSVM   \n                           (with --y_data, --z_data, --y_cost, and --z_cost \n                           options)  (default=off)",
  "      --joint_SPL        use Joint model (y+z) using Self-Paced Learning for \n                           modified Latent SSVM (with --y_data, --z_data, \n                           --y_cost, and --z_cost options)  (default=off)",
  "      --y_data=STRING    set file name for y_train_data (y is visible and z is \n                           hidden)",
  "      --z_data=STRING    set file name for z_train_data (y is hidden and z is \n                           visible)",
  "      --y_cost=FLOAT     set cost of y_train_data in joint model  (default=`1')",
  "      --z_cost=FLOAT     set cost of z_train_data in joint model  (default=`1')",
  "      --y_train_num=INT  set number of sentences of y_train_data for training \n                           (for experiments) (disabled if use 0)  (default=`0')",
  "      --z_train_num=INT  set number of sentences of y_train_data for training \n                           (for experiments) (disabled if use 0)  (default=`0')",
  "      --init_iter=INT    initial iterations for Joint SSVM training algorithm  \n                           (default=`10')",
  "\nPredict options:",
  "  -o, --output=STRING    prediction output filename",
  "      --nbest=INT        print N-best result  (default=`1')",
  "      --beam=INT         set number of beam in search (disabled if use 0)  \n                           (default=`0')",
  "\nConvert option:",
  "  -t, --threshold=FLOAT  set threshold (convert mode)  (default=`1e-04')",
  "\n Group: MODE",
  "  -p, --predict          prediction mode, default is training mode",
  "      --show             show-feature mode",
  "      --convert          convert mode ('txt model to bin model' or 'bin model \n                           to txt model (with -b)') and remove zero features \n                           (with --threshold option)",
  "      --convert2         convert2 mode (all_feaure model to support_feature \n                           model) and remove zero features (with --threshold \n                           option)",
  "      --convert3         convert3 mode (support_feature model to all_feature \n                           model) and remove zero features (with --threshold \n                           option)",
  "      --modify=STRING    modify mode (modify feature weight), the option file \n                           is a list of feature weight",
  "      --domain           domain adaptation (Prior model) for structural SVM \n                           (with fsmo/fsmo_joint/pegasos algorithms and source \n                           option)",
  "\n Group: Parameter Estimate Method for structural SVM",
  "      --fsmo             use Fixed-threshold SMO for structural SVM (shared \n                           slack)",
  "      --fsmo_joint       use FSMO + joint constraint (1-slack) using Gram \n                           matrix",
  "      --fsmo_joint2      use FSMO + joint constraint (1-slack) without Gram \n                           matrix (slow version)",
  "      --pegasos          use Pegasos in primal optimization (random shuffled \n                           train_data) (default method)",
    0
};

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error);


static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->help_given = 0 ;
  args_info->version_given = 0 ;
  args_info->cost_given = 0 ;
  args_info->model_given = 0 ;
  args_info->binary_given = 0 ;
  args_info->source_given = 0 ;
  args_info->skip_eval_given = 0 ;
  args_info->owps_format_given = 0 ;
  args_info->hash_given = 0 ;
  args_info->support_given = 0 ;
  args_info->general_given = 0 ;
  args_info->random_given = 0 ;
  args_info->train_num_given = 0 ;
  args_info->verbose_given = 0 ;
  args_info->epsilon_given = 0 ;
  args_info->buf_given = 0 ;
  args_info->rm_inactive_given = 0 ;
  args_info->final_opt_given = 0 ;
  args_info->comment_given = 0 ;
  args_info->iter_given = 0 ;
  args_info->period_given = 0 ;
  args_info->latent_given = 0 ;
  args_info->latent_SPL_given = 0 ;
  args_info->joint_given = 0 ;
  args_info->joint_SPL_given = 0 ;
  args_info->y_data_given = 0 ;
  args_info->z_data_given = 0 ;
  args_info->y_cost_given = 0 ;
  args_info->z_cost_given = 0 ;
  args_info->y_train_num_given = 0 ;
  args_info->z_train_num_given = 0 ;
  args_info->init_iter_given = 0 ;
  args_info->output_given = 0 ;
  args_info->nbest_given = 0 ;
  args_info->beam_given = 0 ;
  args_info->threshold_given = 0 ;
  args_info->predict_given = 0 ;
  args_info->show_given = 0 ;
  args_info->convert_given = 0 ;
  args_info->convert2_given = 0 ;
  args_info->convert3_given = 0 ;
  args_info->modify_given = 0 ;
  args_info->domain_given = 0 ;
  args_info->fsmo_given = 0 ;
  args_info->fsmo_joint_given = 0 ;
  args_info->fsmo_joint2_given = 0 ;
  args_info->pegasos_given = 0 ;
  args_info->MODE_group_counter = 0 ;
  args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  args_info->cost_arg = 1;
  args_info->cost_orig = NULL;
  args_info->model_arg = NULL;
  args_info->model_orig = NULL;
  args_info->binary_flag = 0;
  args_info->source_arg = NULL;
  args_info->source_orig = NULL;
  args_info->skip_eval_flag = 0;
  args_info->owps_format_flag = 0;
  args_info->hash_arg = 0;
  args_info->hash_orig = NULL;
  args_info->support_flag = 0;
  args_info->general_flag = 0;
  args_info->random_arg = 0;
  args_info->random_orig = NULL;
  args_info->train_num_arg = 0;
  args_info->train_num_orig = NULL;
  args_info->verbose_flag = 0;
  args_info->epsilon_arg = 0.01;
  args_info->epsilon_orig = NULL;
  args_info->buf_arg = 100;
  args_info->buf_orig = NULL;
  args_info->rm_inactive_arg = 50;
  args_info->rm_inactive_orig = NULL;
  args_info->final_opt_flag = 0;
  args_info->comment_flag = 0;
  args_info->iter_arg = 100;
  args_info->iter_orig = NULL;
  args_info->period_arg = 0;
  args_info->period_orig = NULL;
  args_info->latent_flag = 0;
  args_info->latent_SPL_flag = 0;
  args_info->joint_flag = 0;
  args_info->joint_SPL_flag = 0;
  args_info->y_data_arg = NULL;
  args_info->y_data_orig = NULL;
  args_info->z_data_arg = NULL;
  args_info->z_data_orig = NULL;
  args_info->y_cost_arg = 1;
  args_info->y_cost_orig = NULL;
  args_info->z_cost_arg = 1;
  args_info->z_cost_orig = NULL;
  args_info->y_train_num_arg = 0;
  args_info->y_train_num_orig = NULL;
  args_info->z_train_num_arg = 0;
  args_info->z_train_num_orig = NULL;
  args_info->init_iter_arg = 10;
  args_info->init_iter_orig = NULL;
  args_info->output_arg = NULL;
  args_info->output_orig = NULL;
  args_info->nbest_arg = 1;
  args_info->nbest_orig = NULL;
  args_info->beam_arg = 0;
  args_info->beam_orig = NULL;
  args_info->threshold_arg = 1e-04;
  args_info->threshold_orig = NULL;
  args_info->modify_arg = NULL;
  args_info->modify_orig = NULL;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  args_info->help_help = gengetopt_args_info_help[0] ;
  args_info->version_help = gengetopt_args_info_help[1] ;
  args_info->cost_help = gengetopt_args_info_help[3] ;
  args_info->model_help = gengetopt_args_info_help[4] ;
  args_info->binary_help = gengetopt_args_info_help[5] ;
  args_info->source_help = gengetopt_args_info_help[6] ;
  args_info->skip_eval_help = gengetopt_args_info_help[7] ;
  args_info->owps_format_help = gengetopt_args_info_help[8] ;
  args_info->hash_help = gengetopt_args_info_help[9] ;
  args_info->support_help = gengetopt_args_info_help[10] ;
  args_info->general_help = gengetopt_args_info_help[11] ;
  args_info->random_help = gengetopt_args_info_help[12] ;
  args_info->train_num_help = gengetopt_args_info_help[13] ;
  args_info->verbose_help = gengetopt_args_info_help[14] ;
  args_info->epsilon_help = gengetopt_args_info_help[16] ;
  args_info->buf_help = gengetopt_args_info_help[17] ;
  args_info->rm_inactive_help = gengetopt_args_info_help[18] ;
  args_info->final_opt_help = gengetopt_args_info_help[19] ;
  args_info->comment_help = gengetopt_args_info_help[20] ;
  args_info->iter_help = gengetopt_args_info_help[22] ;
  args_info->period_help = gengetopt_args_info_help[23] ;
  args_info->latent_help = gengetopt_args_info_help[25] ;
  args_info->latent_SPL_help = gengetopt_args_info_help[26] ;
  args_info->joint_help = gengetopt_args_info_help[28] ;
  args_info->joint_SPL_help = gengetopt_args_info_help[29] ;
  args_info->y_data_help = gengetopt_args_info_help[30] ;
  args_info->z_data_help = gengetopt_args_info_help[31] ;
  args_info->y_cost_help = gengetopt_args_info_help[32] ;
  args_info->z_cost_help = gengetopt_args_info_help[33] ;
  args_info->y_train_num_help = gengetopt_args_info_help[34] ;
  args_info->z_train_num_help = gengetopt_args_info_help[35] ;
  args_info->init_iter_help = gengetopt_args_info_help[36] ;
  args_info->output_help = gengetopt_args_info_help[38] ;
  args_info->nbest_help = gengetopt_args_info_help[39] ;
  args_info->beam_help = gengetopt_args_info_help[40] ;
  args_info->threshold_help = gengetopt_args_info_help[42] ;
  args_info->predict_help = gengetopt_args_info_help[43] ;
  args_info->show_help = gengetopt_args_info_help[44] ;
  args_info->convert_help = gengetopt_args_info_help[45] ;
  args_info->convert2_help = gengetopt_args_info_help[46] ;
  args_info->convert3_help = gengetopt_args_info_help[47] ;
  args_info->modify_help = gengetopt_args_info_help[48] ;
  args_info->domain_help = gengetopt_args_info_help[49] ;
  args_info->fsmo_help = gengetopt_args_info_help[50] ;
  args_info->fsmo_joint_help = gengetopt_args_info_help[51] ;
  args_info->fsmo_joint2_help = gengetopt_args_info_help[52] ;
  args_info->pegasos_help = gengetopt_args_info_help[53] ;
  
}

void
cmdline_parser_print_version (void)
{
  printf ("%s %s\n", CMDLINE_PARSER_PACKAGE, CMDLINE_PARSER_VERSION);
}

void
cmdline_parser_print_help (void)
{
  int i = 0;
  cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  printf("\n%s\n\n", gengetopt_args_info_usage);

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n", gengetopt_args_info_description);

  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = NULL;
  args_info->inputs_num = 0;
}

static void
cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  
  unsigned int i;
  if (args_info->cost_orig)
    {
      free (args_info->cost_orig); /* free previous argument */
      args_info->cost_orig = 0;
    }
  if (args_info->model_arg)
    {
      free (args_info->model_arg); /* free previous argument */
      args_info->model_arg = 0;
    }
  if (args_info->model_orig)
    {
      free (args_info->model_orig); /* free previous argument */
      args_info->model_orig = 0;
    }
  if (args_info->source_arg)
    {
      free (args_info->source_arg); /* free previous argument */
      args_info->source_arg = 0;
    }
  if (args_info->source_orig)
    {
      free (args_info->source_orig); /* free previous argument */
      args_info->source_orig = 0;
    }
  if (args_info->hash_orig)
    {
      free (args_info->hash_orig); /* free previous argument */
      args_info->hash_orig = 0;
    }
  if (args_info->random_orig)
    {
      free (args_info->random_orig); /* free previous argument */
      args_info->random_orig = 0;
    }
  if (args_info->train_num_orig)
    {
      free (args_info->train_num_orig); /* free previous argument */
      args_info->train_num_orig = 0;
    }
  if (args_info->epsilon_orig)
    {
      free (args_info->epsilon_orig); /* free previous argument */
      args_info->epsilon_orig = 0;
    }
  if (args_info->buf_orig)
    {
      free (args_info->buf_orig); /* free previous argument */
      args_info->buf_orig = 0;
    }
  if (args_info->rm_inactive_orig)
    {
      free (args_info->rm_inactive_orig); /* free previous argument */
      args_info->rm_inactive_orig = 0;
    }
  if (args_info->iter_orig)
    {
      free (args_info->iter_orig); /* free previous argument */
      args_info->iter_orig = 0;
    }
  if (args_info->period_orig)
    {
      free (args_info->period_orig); /* free previous argument */
      args_info->period_orig = 0;
    }
  if (args_info->y_data_arg)
    {
      free (args_info->y_data_arg); /* free previous argument */
      args_info->y_data_arg = 0;
    }
  if (args_info->y_data_orig)
    {
      free (args_info->y_data_orig); /* free previous argument */
      args_info->y_data_orig = 0;
    }
  if (args_info->z_data_arg)
    {
      free (args_info->z_data_arg); /* free previous argument */
      args_info->z_data_arg = 0;
    }
  if (args_info->z_data_orig)
    {
      free (args_info->z_data_orig); /* free previous argument */
      args_info->z_data_orig = 0;
    }
  if (args_info->y_cost_orig)
    {
      free (args_info->y_cost_orig); /* free previous argument */
      args_info->y_cost_orig = 0;
    }
  if (args_info->z_cost_orig)
    {
      free (args_info->z_cost_orig); /* free previous argument */
      args_info->z_cost_orig = 0;
    }
  if (args_info->y_train_num_orig)
    {
      free (args_info->y_train_num_orig); /* free previous argument */
      args_info->y_train_num_orig = 0;
    }
  if (args_info->z_train_num_orig)
    {
      free (args_info->z_train_num_orig); /* free previous argument */
      args_info->z_train_num_orig = 0;
    }
  if (args_info->init_iter_orig)
    {
      free (args_info->init_iter_orig); /* free previous argument */
      args_info->init_iter_orig = 0;
    }
  if (args_info->output_arg)
    {
      free (args_info->output_arg); /* free previous argument */
      args_info->output_arg = 0;
    }
  if (args_info->output_orig)
    {
      free (args_info->output_orig); /* free previous argument */
      args_info->output_orig = 0;
    }
  if (args_info->nbest_orig)
    {
      free (args_info->nbest_orig); /* free previous argument */
      args_info->nbest_orig = 0;
    }
  if (args_info->beam_orig)
    {
      free (args_info->beam_orig); /* free previous argument */
      args_info->beam_orig = 0;
    }
  if (args_info->threshold_orig)
    {
      free (args_info->threshold_orig); /* free previous argument */
      args_info->threshold_orig = 0;
    }
  if (args_info->modify_arg)
    {
      free (args_info->modify_arg); /* free previous argument */
      args_info->modify_arg = 0;
    }
  if (args_info->modify_orig)
    {
      free (args_info->modify_orig); /* free previous argument */
      args_info->modify_orig = 0;
    }
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);
  
  if (args_info->inputs_num)
    free (args_info->inputs);
  
  clear_given (args_info);
}

int
cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  if (args_info->help_given) {
    fprintf(outfile, "%s\n", "help");
  }
  if (args_info->version_given) {
    fprintf(outfile, "%s\n", "version");
  }
  if (args_info->cost_given) {
    if (args_info->cost_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "cost", args_info->cost_orig);
    } else {
      fprintf(outfile, "%s\n", "cost");
    }
  }
  if (args_info->model_given) {
    if (args_info->model_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "model", args_info->model_orig);
    } else {
      fprintf(outfile, "%s\n", "model");
    }
  }
  if (args_info->binary_given) {
    fprintf(outfile, "%s\n", "binary");
  }
  if (args_info->source_given) {
    if (args_info->source_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "source", args_info->source_orig);
    } else {
      fprintf(outfile, "%s\n", "source");
    }
  }
  if (args_info->skip_eval_given) {
    fprintf(outfile, "%s\n", "skip_eval");
  }
  if (args_info->owps_format_given) {
    fprintf(outfile, "%s\n", "owps_format");
  }
  if (args_info->hash_given) {
    if (args_info->hash_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "hash", args_info->hash_orig);
    } else {
      fprintf(outfile, "%s\n", "hash");
    }
  }
  if (args_info->support_given) {
    fprintf(outfile, "%s\n", "support");
  }
  if (args_info->general_given) {
    fprintf(outfile, "%s\n", "general");
  }
  if (args_info->random_given) {
    if (args_info->random_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "random", args_info->random_orig);
    } else {
      fprintf(outfile, "%s\n", "random");
    }
  }
  if (args_info->train_num_given) {
    if (args_info->train_num_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "train_num", args_info->train_num_orig);
    } else {
      fprintf(outfile, "%s\n", "train_num");
    }
  }
  if (args_info->verbose_given) {
    fprintf(outfile, "%s\n", "verbose");
  }
  if (args_info->epsilon_given) {
    if (args_info->epsilon_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "epsilon", args_info->epsilon_orig);
    } else {
      fprintf(outfile, "%s\n", "epsilon");
    }
  }
  if (args_info->buf_given) {
    if (args_info->buf_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "buf", args_info->buf_orig);
    } else {
      fprintf(outfile, "%s\n", "buf");
    }
  }
  if (args_info->rm_inactive_given) {
    if (args_info->rm_inactive_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "rm_inactive", args_info->rm_inactive_orig);
    } else {
      fprintf(outfile, "%s\n", "rm_inactive");
    }
  }
  if (args_info->final_opt_given) {
    fprintf(outfile, "%s\n", "final_opt");
  }
  if (args_info->comment_given) {
    fprintf(outfile, "%s\n", "comment");
  }
  if (args_info->iter_given) {
    if (args_info->iter_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "iter", args_info->iter_orig);
    } else {
      fprintf(outfile, "%s\n", "iter");
    }
  }
  if (args_info->period_given) {
    if (args_info->period_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "period", args_info->period_orig);
    } else {
      fprintf(outfile, "%s\n", "period");
    }
  }
  if (args_info->latent_given) {
    fprintf(outfile, "%s\n", "latent");
  }
  if (args_info->latent_SPL_given) {
    fprintf(outfile, "%s\n", "latent_SPL");
  }
  if (args_info->joint_given) {
    fprintf(outfile, "%s\n", "joint");
  }
  if (args_info->joint_SPL_given) {
    fprintf(outfile, "%s\n", "joint_SPL");
  }
  if (args_info->y_data_given) {
    if (args_info->y_data_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "y_data", args_info->y_data_orig);
    } else {
      fprintf(outfile, "%s\n", "y_data");
    }
  }
  if (args_info->z_data_given) {
    if (args_info->z_data_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "z_data", args_info->z_data_orig);
    } else {
      fprintf(outfile, "%s\n", "z_data");
    }
  }
  if (args_info->y_cost_given) {
    if (args_info->y_cost_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "y_cost", args_info->y_cost_orig);
    } else {
      fprintf(outfile, "%s\n", "y_cost");
    }
  }
  if (args_info->z_cost_given) {
    if (args_info->z_cost_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "z_cost", args_info->z_cost_orig);
    } else {
      fprintf(outfile, "%s\n", "z_cost");
    }
  }
  if (args_info->y_train_num_given) {
    if (args_info->y_train_num_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "y_train_num", args_info->y_train_num_orig);
    } else {
      fprintf(outfile, "%s\n", "y_train_num");
    }
  }
  if (args_info->z_train_num_given) {
    if (args_info->z_train_num_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "z_train_num", args_info->z_train_num_orig);
    } else {
      fprintf(outfile, "%s\n", "z_train_num");
    }
  }
  if (args_info->init_iter_given) {
    if (args_info->init_iter_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "init_iter", args_info->init_iter_orig);
    } else {
      fprintf(outfile, "%s\n", "init_iter");
    }
  }
  if (args_info->output_given) {
    if (args_info->output_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "output", args_info->output_orig);
    } else {
      fprintf(outfile, "%s\n", "output");
    }
  }
  if (args_info->nbest_given) {
    if (args_info->nbest_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "nbest", args_info->nbest_orig);
    } else {
      fprintf(outfile, "%s\n", "nbest");
    }
  }
  if (args_info->beam_given) {
    if (args_info->beam_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "beam", args_info->beam_orig);
    } else {
      fprintf(outfile, "%s\n", "beam");
    }
  }
  if (args_info->threshold_given) {
    if (args_info->threshold_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "threshold", args_info->threshold_orig);
    } else {
      fprintf(outfile, "%s\n", "threshold");
    }
  }
  if (args_info->predict_given) {
    fprintf(outfile, "%s\n", "predict");
  }
  if (args_info->show_given) {
    fprintf(outfile, "%s\n", "show");
  }
  if (args_info->convert_given) {
    fprintf(outfile, "%s\n", "convert");
  }
  if (args_info->convert2_given) {
    fprintf(outfile, "%s\n", "convert2");
  }
  if (args_info->convert3_given) {
    fprintf(outfile, "%s\n", "convert3");
  }
  if (args_info->modify_given) {
    if (args_info->modify_orig) {
      fprintf(outfile, "%s=\"%s\"\n", "modify", args_info->modify_orig);
    } else {
      fprintf(outfile, "%s\n", "modify");
    }
  }
  if (args_info->domain_given) {
    fprintf(outfile, "%s\n", "domain");
  }
  if (args_info->fsmo_given) {
    fprintf(outfile, "%s\n", "fsmo");
  }
  if (args_info->fsmo_joint_given) {
    fprintf(outfile, "%s\n", "fsmo_joint");
  }
  if (args_info->fsmo_joint2_given) {
    fprintf(outfile, "%s\n", "fsmo_joint2");
  }
  if (args_info->pegasos_given) {
    fprintf(outfile, "%s\n", "pegasos");
  }
  
  fclose (outfile);

  i = EXIT_SUCCESS;
  return i;
}

void
cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  cmdline_parser_release (args_info);
}


/* gengetopt_strdup() */
/* strdup.c replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = NULL;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

static void
reset_group_MODE(struct gengetopt_args_info *args_info);

static void
reset_group_MODE(struct gengetopt_args_info *args_info)
{
  if (! args_info->MODE_group_counter)
    return;
  
  args_info->predict_given = 0 ;
  args_info->show_given = 0 ;
  args_info->convert_given = 0 ;
  args_info->convert2_given = 0 ;
  args_info->convert3_given = 0 ;
  args_info->modify_given = 0 ;
  if (args_info->modify_arg)
    {
      free (args_info->modify_arg); /* free previous argument */
      args_info->modify_arg = 0;
    }
  if (args_info->modify_orig)
    {
      free (args_info->modify_orig); /* free previous argument */
      args_info->modify_orig = 0;
    }
  args_info->domain_given = 0 ;

  args_info->MODE_group_counter = 0;
}

static void
reset_group_Parameter_Estimate_Method_for_structural_SVM(struct gengetopt_args_info *args_info);

static void
reset_group_Parameter_Estimate_Method_for_structural_SVM(struct gengetopt_args_info *args_info)
{
  if (! args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter)
    return;
  
  args_info->fsmo_given = 0 ;
  args_info->fsmo_joint_given = 0 ;
  args_info->fsmo_joint2_given = 0 ;
  args_info->pegasos_given = 0 ;

  args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter = 0;
}

int
cmdline_parser (int argc, char * const *argv, struct gengetopt_args_info *args_info)
{
  return cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
cmdline_parser2 (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;

  result = cmdline_parser_internal (argc, argv, args_info, override, initialize, check_required, NULL);

  if (result == EXIT_FAILURE)
    {
      cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  return EXIT_SUCCESS;
}

int
cmdline_parser_internal (int argc, char * const *argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error = 0;
  struct gengetopt_args_info local_args_info;

  if (initialize)
    cmdline_parser_init (args_info);

  cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = 1;
  optopt = '?';

  while (1)
    {
      int option_index = 0;
      char *stop_char;

      static struct option long_options[] = {
        { "help",	0, NULL, 'h' },
        { "version",	0, NULL, 'V' },
        { "cost",	1, NULL, 'c' },
        { "model",	1, NULL, 'm' },
        { "binary",	0, NULL, 'b' },
        { "source",	1, NULL, 0 },
        { "skip_eval",	0, NULL, 0 },
        { "owps_format",	0, NULL, 0 },
        { "hash",	1, NULL, 0 },
        { "support",	0, NULL, 's' },
        { "general",	0, NULL, 0 },
        { "random",	1, NULL, 'r' },
        { "train_num",	1, NULL, 0 },
        { "verbose",	0, NULL, 'v' },
        { "epsilon",	1, NULL, 'e' },
        { "buf",	1, NULL, 0 },
        { "rm_inactive",	1, NULL, 0 },
        { "final_opt",	0, NULL, 0 },
        { "comment",	0, NULL, 0 },
        { "iter",	1, NULL, 'i' },
        { "period",	1, NULL, 0 },
        { "latent",	0, NULL, 0 },
        { "latent_SPL",	0, NULL, 0 },
        { "joint",	0, NULL, 0 },
        { "joint_SPL",	0, NULL, 0 },
        { "y_data",	1, NULL, 0 },
        { "z_data",	1, NULL, 0 },
        { "y_cost",	1, NULL, 0 },
        { "z_cost",	1, NULL, 0 },
        { "y_train_num",	1, NULL, 0 },
        { "z_train_num",	1, NULL, 0 },
        { "init_iter",	1, NULL, 0 },
        { "output",	1, NULL, 'o' },
        { "nbest",	1, NULL, 0 },
        { "beam",	1, NULL, 0 },
        { "threshold",	1, NULL, 't' },
        { "predict",	0, NULL, 'p' },
        { "show",	0, NULL, 0 },
        { "convert",	0, NULL, 0 },
        { "convert2",	0, NULL, 0 },
        { "convert3",	0, NULL, 0 },
        { "modify",	1, NULL, 0 },
        { "domain",	0, NULL, 0 },
        { "fsmo",	0, NULL, 0 },
        { "fsmo_joint",	0, NULL, 0 },
        { "fsmo_joint2",	0, NULL, 0 },
        { "pegasos",	0, NULL, 0 },
        { NULL,	0, NULL, 0 }
      };

      stop_char = 0;
      c = getopt_long (argc, argv, "hVc:m:bsr:ve:i:o:t:p", long_options, &option_index);

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'h':	/* Print help and exit.  */
          cmdline_parser_print_help ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'V':	/* Print version and exit.  */
          cmdline_parser_print_version ();
          cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'c':	/* set cost of SSVMs.  */
          if (local_args_info.cost_given)
            {
              fprintf (stderr, "%s: `--cost' (`-c') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->cost_given && ! override)
            continue;
          local_args_info.cost_given = 1;
          args_info->cost_given = 1;
          args_info->cost_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->cost_orig)
            free (args_info->cost_orig); /* free previous string */
          args_info->cost_orig = gengetopt_strdup (optarg);
          break;

        case 'm':	/* set model file name.  */
          if (local_args_info.model_given)
            {
              fprintf (stderr, "%s: `--model' (`-m') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->model_given && ! override)
            continue;
          local_args_info.model_given = 1;
          args_info->model_given = 1;
          if (args_info->model_arg)
            free (args_info->model_arg); /* free previous string */
          args_info->model_arg = gengetopt_strdup (optarg);
          if (args_info->model_orig)
            free (args_info->model_orig); /* free previous string */
          args_info->model_orig = gengetopt_strdup (optarg);
          break;

        case 'b':	/* save/load model in binary format.  */
          if (local_args_info.binary_given)
            {
              fprintf (stderr, "%s: `--binary' (`-b') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->binary_given && ! override)
            continue;
          local_args_info.binary_given = 1;
          args_info->binary_given = 1;
          args_info->binary_flag = !(args_info->binary_flag);
          break;

        case 's':	/* use support feature (default is all feature).  */
          if (local_args_info.support_given)
            {
              fprintf (stderr, "%s: `--support' (`-s') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->support_given && ! override)
            continue;
          local_args_info.support_given = 1;
          args_info->support_given = 1;
          args_info->support_flag = !(args_info->support_flag);
          break;

        case 'r':	/* use random_shuffle in train_data (disabled if use 0).  */
          if (local_args_info.random_given)
            {
              fprintf (stderr, "%s: `--random' (`-r') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->random_given && ! override)
            continue;
          local_args_info.random_given = 1;
          args_info->random_given = 1;
          args_info->random_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->random_orig)
            free (args_info->random_orig); /* free previous string */
          args_info->random_orig = gengetopt_strdup (optarg);
          break;

        case 'v':	/* verbose mode.  */
          if (local_args_info.verbose_given)
            {
              fprintf (stderr, "%s: `--verbose' (`-v') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->verbose_given && ! override)
            continue;
          local_args_info.verbose_given = 1;
          args_info->verbose_given = 1;
          args_info->verbose_flag = !(args_info->verbose_flag);
          break;

        case 'e':	/* set epsilon (fsmo, fsmo_joint).  */
          if (local_args_info.epsilon_given)
            {
              fprintf (stderr, "%s: `--epsilon' (`-e') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->epsilon_given && ! override)
            continue;
          local_args_info.epsilon_given = 1;
          args_info->epsilon_given = 1;
          args_info->epsilon_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->epsilon_orig)
            free (args_info->epsilon_orig); /* free previous string */
          args_info->epsilon_orig = gengetopt_strdup (optarg);
          break;

        case 'i':	/* iterations for training algorithm (pegasos).  */
          if (local_args_info.iter_given)
            {
              fprintf (stderr, "%s: `--iter' (`-i') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->iter_given && ! override)
            continue;
          local_args_info.iter_given = 1;
          args_info->iter_given = 1;
          args_info->iter_arg = strtol (optarg, &stop_char, 0);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->iter_orig)
            free (args_info->iter_orig); /* free previous string */
          args_info->iter_orig = gengetopt_strdup (optarg);
          break;

        case 'o':	/* prediction output filename.  */
          if (local_args_info.output_given)
            {
              fprintf (stderr, "%s: `--output' (`-o') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->output_given && ! override)
            continue;
          local_args_info.output_given = 1;
          args_info->output_given = 1;
          if (args_info->output_arg)
            free (args_info->output_arg); /* free previous string */
          args_info->output_arg = gengetopt_strdup (optarg);
          if (args_info->output_orig)
            free (args_info->output_orig); /* free previous string */
          args_info->output_orig = gengetopt_strdup (optarg);
          break;

        case 't':	/* set threshold (convert mode).  */
          if (local_args_info.threshold_given)
            {
              fprintf (stderr, "%s: `--threshold' (`-t') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->threshold_given && ! override)
            continue;
          local_args_info.threshold_given = 1;
          args_info->threshold_given = 1;
          args_info->threshold_arg = (float)strtod (optarg, &stop_char);
          if (!(stop_char && *stop_char == '\0')) {
            fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
            goto failure;
          }
          if (args_info->threshold_orig)
            free (args_info->threshold_orig); /* free previous string */
          args_info->threshold_orig = gengetopt_strdup (optarg);
          break;

        case 'p':	/* prediction mode, default is training mode.  */
          if (local_args_info.predict_given)
            {
              fprintf (stderr, "%s: `--predict' (`-p') option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
              goto failure;
            }
          if (args_info->predict_given && ! override)
            continue;
          local_args_info.predict_given = 1;
          args_info->predict_given = 1;
          if (args_info->MODE_group_counter && override)
            reset_group_MODE (args_info);
          args_info->MODE_group_counter += 1;
          break;


        case 0:	/* Long option with no short option */
          /* source model file for domain adaptation.  */
          if (strcmp (long_options[option_index].name, "source") == 0)
          {
            if (local_args_info.source_given)
              {
                fprintf (stderr, "%s: `--source' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->source_given && ! override)
              continue;
            local_args_info.source_given = 1;
            args_info->source_given = 1;
            if (args_info->source_arg)
              free (args_info->source_arg); /* free previous string */
            args_info->source_arg = gengetopt_strdup (optarg);
            if (args_info->source_orig)
              free (args_info->source_orig); /* free previous string */
            args_info->source_orig = gengetopt_strdup (optarg);
          }
          /* skip test set evaluation in the middle of training.  */
          else if (strcmp (long_options[option_index].name, "skip_eval") == 0)
          {
            if (local_args_info.skip_eval_given)
              {
                fprintf (stderr, "%s: `--skip_eval' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->skip_eval_given && ! override)
              continue;
            local_args_info.skip_eval_given = 1;
            args_info->skip_eval_given = 1;
            args_info->skip_eval_flag = !(args_info->skip_eval_flag);
          }
          /* use One Word Per Sentence (OWPS) format.  */
          else if (strcmp (long_options[option_index].name, "owps_format") == 0)
          {
            if (local_args_info.owps_format_given)
              {
                fprintf (stderr, "%s: `--owps_format' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->owps_format_given && ! override)
              continue;
            local_args_info.owps_format_given = 1;
            args_info->owps_format_given = 1;
            args_info->owps_format_flag = !(args_info->owps_format_flag);
          }
          /* use hash feature and set number of predicates.  */
          else if (strcmp (long_options[option_index].name, "hash") == 0)
          {
            if (local_args_info.hash_given)
              {
                fprintf (stderr, "%s: `--hash' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->hash_given && ! override)
              continue;
            local_args_info.hash_given = 1;
            args_info->hash_given = 1;
            args_info->hash_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->hash_orig)
              free (args_info->hash_orig); /* free previous string */
            args_info->hash_orig = gengetopt_strdup (optarg);
          }
          /* general feature mode (feature:value format) (default is binary feature).  */
          else if (strcmp (long_options[option_index].name, "general") == 0)
          {
            if (local_args_info.general_given)
              {
                fprintf (stderr, "%s: `--general' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->general_given && ! override)
              continue;
            local_args_info.general_given = 1;
            args_info->general_given = 1;
            args_info->general_flag = !(args_info->general_flag);
          }
          /* set number of sentence in train_data for training (for experiments) (disabled if use 0).  */
          else if (strcmp (long_options[option_index].name, "train_num") == 0)
          {
            if (local_args_info.train_num_given)
              {
                fprintf (stderr, "%s: `--train_num' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->train_num_given && ! override)
              continue;
            local_args_info.train_num_given = 1;
            args_info->train_num_given = 1;
            args_info->train_num_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->train_num_orig)
              free (args_info->train_num_orig); /* free previous string */
            args_info->train_num_orig = gengetopt_strdup (optarg);
          }
          /* set the number of new constraints to accumulated before recomputing the QP (fsmo, pegasos).  */
          else if (strcmp (long_options[option_index].name, "buf") == 0)
          {
            if (local_args_info.buf_given)
              {
                fprintf (stderr, "%s: `--buf' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->buf_given && ! override)
              continue;
            local_args_info.buf_given = 1;
            args_info->buf_given = 1;
            args_info->buf_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->buf_orig)
              free (args_info->buf_orig); /* free previous string */
            args_info->buf_orig = gengetopt_strdup (optarg);
          }
          /* inactive constraints are removed (iteration) (fsmo, fsmo_joint).  */
          else if (strcmp (long_options[option_index].name, "rm_inactive") == 0)
          {
            if (local_args_info.rm_inactive_given)
              {
                fprintf (stderr, "%s: `--rm_inactive' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->rm_inactive_given && ! override)
              continue;
            local_args_info.rm_inactive_given = 1;
            args_info->rm_inactive_given = 1;
            args_info->rm_inactive_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->rm_inactive_orig)
              free (args_info->rm_inactive_orig); /* free previous string */
            args_info->rm_inactive_orig = gengetopt_strdup (optarg);
          }
          /* do final optimal check in shrinking (fsmo, fsmo_joint).  */
          else if (strcmp (long_options[option_index].name, "final_opt") == 0)
          {
            if (local_args_info.final_opt_given)
              {
                fprintf (stderr, "%s: `--final_opt' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->final_opt_given && ! override)
              continue;
            local_args_info.final_opt_given = 1;
            args_info->final_opt_given = 1;
            args_info->final_opt_flag = !(args_info->final_opt_flag);
          }
          /* use comment info in save_slack() (fsmo).  */
          else if (strcmp (long_options[option_index].name, "comment") == 0)
          {
            if (local_args_info.comment_given)
              {
                fprintf (stderr, "%s: `--comment' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->comment_given && ! override)
              continue;
            local_args_info.comment_given = 1;
            args_info->comment_given = 1;
            args_info->comment_flag = !(args_info->comment_flag);
          }
          /* save model periodically (pegasos).  */
          else if (strcmp (long_options[option_index].name, "period") == 0)
          {
            if (local_args_info.period_given)
              {
                fprintf (stderr, "%s: `--period' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->period_given && ! override)
              continue;
            local_args_info.period_given = 1;
            args_info->period_given = 1;
            args_info->period_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->period_orig)
              free (args_info->period_orig); /* free previous string */
            args_info->period_orig = gengetopt_strdup (optarg);
          }
          /* use CCCP-based Latent SSVM (doesn't support sequence labeling).  */
          else if (strcmp (long_options[option_index].name, "latent") == 0)
          {
            if (local_args_info.latent_given)
              {
                fprintf (stderr, "%s: `--latent' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->latent_given && ! override)
              continue;
            local_args_info.latent_given = 1;
            args_info->latent_given = 1;
            args_info->latent_flag = !(args_info->latent_flag);
          }
          /* use Self-Paced Learning for Latent SSVM (doesn't support sequence labeling).  */
          else if (strcmp (long_options[option_index].name, "latent_SPL") == 0)
          {
            if (local_args_info.latent_SPL_given)
              {
                fprintf (stderr, "%s: `--latent_SPL' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->latent_SPL_given && ! override)
              continue;
            local_args_info.latent_SPL_given = 1;
            args_info->latent_SPL_given = 1;
            args_info->latent_SPL_flag = !(args_info->latent_SPL_flag);
          }
          /* use Joint model (y+z) using modified Latent SSVM   (with --y_data, --z_data, --y_cost, and --z_cost options).  */
          else if (strcmp (long_options[option_index].name, "joint") == 0)
          {
            if (local_args_info.joint_given)
              {
                fprintf (stderr, "%s: `--joint' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->joint_given && ! override)
              continue;
            local_args_info.joint_given = 1;
            args_info->joint_given = 1;
            args_info->joint_flag = !(args_info->joint_flag);
          }
          /* use Joint model (y+z) using Self-Paced Learning for modified Latent SSVM (with --y_data, --z_data, --y_cost, and --z_cost options).  */
          else if (strcmp (long_options[option_index].name, "joint_SPL") == 0)
          {
            if (local_args_info.joint_SPL_given)
              {
                fprintf (stderr, "%s: `--joint_SPL' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->joint_SPL_given && ! override)
              continue;
            local_args_info.joint_SPL_given = 1;
            args_info->joint_SPL_given = 1;
            args_info->joint_SPL_flag = !(args_info->joint_SPL_flag);
          }
          /* set file name for y_train_data (y is visible and z is hidden).  */
          else if (strcmp (long_options[option_index].name, "y_data") == 0)
          {
            if (local_args_info.y_data_given)
              {
                fprintf (stderr, "%s: `--y_data' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->y_data_given && ! override)
              continue;
            local_args_info.y_data_given = 1;
            args_info->y_data_given = 1;
            if (args_info->y_data_arg)
              free (args_info->y_data_arg); /* free previous string */
            args_info->y_data_arg = gengetopt_strdup (optarg);
            if (args_info->y_data_orig)
              free (args_info->y_data_orig); /* free previous string */
            args_info->y_data_orig = gengetopt_strdup (optarg);
          }
          /* set file name for z_train_data (y is hidden and z is visible).  */
          else if (strcmp (long_options[option_index].name, "z_data") == 0)
          {
            if (local_args_info.z_data_given)
              {
                fprintf (stderr, "%s: `--z_data' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->z_data_given && ! override)
              continue;
            local_args_info.z_data_given = 1;
            args_info->z_data_given = 1;
            if (args_info->z_data_arg)
              free (args_info->z_data_arg); /* free previous string */
            args_info->z_data_arg = gengetopt_strdup (optarg);
            if (args_info->z_data_orig)
              free (args_info->z_data_orig); /* free previous string */
            args_info->z_data_orig = gengetopt_strdup (optarg);
          }
          /* set cost of y_train_data in joint model.  */
          else if (strcmp (long_options[option_index].name, "y_cost") == 0)
          {
            if (local_args_info.y_cost_given)
              {
                fprintf (stderr, "%s: `--y_cost' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->y_cost_given && ! override)
              continue;
            local_args_info.y_cost_given = 1;
            args_info->y_cost_given = 1;
            args_info->y_cost_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->y_cost_orig)
              free (args_info->y_cost_orig); /* free previous string */
            args_info->y_cost_orig = gengetopt_strdup (optarg);
          }
          /* set cost of z_train_data in joint model.  */
          else if (strcmp (long_options[option_index].name, "z_cost") == 0)
          {
            if (local_args_info.z_cost_given)
              {
                fprintf (stderr, "%s: `--z_cost' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->z_cost_given && ! override)
              continue;
            local_args_info.z_cost_given = 1;
            args_info->z_cost_given = 1;
            args_info->z_cost_arg = (float)strtod (optarg, &stop_char);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->z_cost_orig)
              free (args_info->z_cost_orig); /* free previous string */
            args_info->z_cost_orig = gengetopt_strdup (optarg);
          }
          /* set number of sentences of y_train_data for training (for experiments) (disabled if use 0).  */
          else if (strcmp (long_options[option_index].name, "y_train_num") == 0)
          {
            if (local_args_info.y_train_num_given)
              {
                fprintf (stderr, "%s: `--y_train_num' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->y_train_num_given && ! override)
              continue;
            local_args_info.y_train_num_given = 1;
            args_info->y_train_num_given = 1;
            args_info->y_train_num_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->y_train_num_orig)
              free (args_info->y_train_num_orig); /* free previous string */
            args_info->y_train_num_orig = gengetopt_strdup (optarg);
          }
          /* set number of sentences of y_train_data for training (for experiments) (disabled if use 0).  */
          else if (strcmp (long_options[option_index].name, "z_train_num") == 0)
          {
            if (local_args_info.z_train_num_given)
              {
                fprintf (stderr, "%s: `--z_train_num' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->z_train_num_given && ! override)
              continue;
            local_args_info.z_train_num_given = 1;
            args_info->z_train_num_given = 1;
            args_info->z_train_num_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->z_train_num_orig)
              free (args_info->z_train_num_orig); /* free previous string */
            args_info->z_train_num_orig = gengetopt_strdup (optarg);
          }
          /* initial iterations for Joint SSVM training algorithm.  */
          else if (strcmp (long_options[option_index].name, "init_iter") == 0)
          {
            if (local_args_info.init_iter_given)
              {
                fprintf (stderr, "%s: `--init_iter' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->init_iter_given && ! override)
              continue;
            local_args_info.init_iter_given = 1;
            args_info->init_iter_given = 1;
            args_info->init_iter_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->init_iter_orig)
              free (args_info->init_iter_orig); /* free previous string */
            args_info->init_iter_orig = gengetopt_strdup (optarg);
          }
          /* print N-best result.  */
          else if (strcmp (long_options[option_index].name, "nbest") == 0)
          {
            if (local_args_info.nbest_given)
              {
                fprintf (stderr, "%s: `--nbest' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->nbest_given && ! override)
              continue;
            local_args_info.nbest_given = 1;
            args_info->nbest_given = 1;
            args_info->nbest_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->nbest_orig)
              free (args_info->nbest_orig); /* free previous string */
            args_info->nbest_orig = gengetopt_strdup (optarg);
          }
          /* set number of beam in search (disabled if use 0).  */
          else if (strcmp (long_options[option_index].name, "beam") == 0)
          {
            if (local_args_info.beam_given)
              {
                fprintf (stderr, "%s: `--beam' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->beam_given && ! override)
              continue;
            local_args_info.beam_given = 1;
            args_info->beam_given = 1;
            args_info->beam_arg = strtol (optarg, &stop_char, 0);
            if (!(stop_char && *stop_char == '\0')) {
              fprintf(stderr, "%s: invalid numeric value: %s\n", argv[0], optarg);
              goto failure;
            }
            if (args_info->beam_orig)
              free (args_info->beam_orig); /* free previous string */
            args_info->beam_orig = gengetopt_strdup (optarg);
          }
          /* show-feature mode.  */
          else if (strcmp (long_options[option_index].name, "show") == 0)
          {
            if (local_args_info.show_given)
              {
                fprintf (stderr, "%s: `--show' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->show_given && ! override)
              continue;
            local_args_info.show_given = 1;
            args_info->show_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* convert mode ('txt model to bin model' or 'bin model to txt model (with -b)') and remove zero features (with --threshold option).  */
          else if (strcmp (long_options[option_index].name, "convert") == 0)
          {
            if (local_args_info.convert_given)
              {
                fprintf (stderr, "%s: `--convert' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->convert_given && ! override)
              continue;
            local_args_info.convert_given = 1;
            args_info->convert_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* convert2 mode (all_feaure model to support_feature model) and remove zero features (with --threshold option).  */
          else if (strcmp (long_options[option_index].name, "convert2") == 0)
          {
            if (local_args_info.convert2_given)
              {
                fprintf (stderr, "%s: `--convert2' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->convert2_given && ! override)
              continue;
            local_args_info.convert2_given = 1;
            args_info->convert2_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* convert3 mode (support_feature model to all_feature model) and remove zero features (with --threshold option).  */
          else if (strcmp (long_options[option_index].name, "convert3") == 0)
          {
            if (local_args_info.convert3_given)
              {
                fprintf (stderr, "%s: `--convert3' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->convert3_given && ! override)
              continue;
            local_args_info.convert3_given = 1;
            args_info->convert3_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* modify mode (modify feature weight), the option file is a list of feature weight.  */
          else if (strcmp (long_options[option_index].name, "modify") == 0)
          {
            if (local_args_info.modify_given)
              {
                fprintf (stderr, "%s: `--modify' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->modify_given && ! override)
              continue;
            local_args_info.modify_given = 1;
            args_info->modify_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            if (args_info->modify_arg)
              free (args_info->modify_arg); /* free previous string */
            args_info->modify_arg = gengetopt_strdup (optarg);
            if (args_info->modify_orig)
              free (args_info->modify_orig); /* free previous string */
            args_info->modify_orig = gengetopt_strdup (optarg);
          }
          /* domain adaptation (Prior model) for structural SVM (with fsmo/fsmo_joint/pegasos algorithms and source option).  */
          else if (strcmp (long_options[option_index].name, "domain") == 0)
          {
            if (local_args_info.domain_given)
              {
                fprintf (stderr, "%s: `--domain' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->domain_given && ! override)
              continue;
            local_args_info.domain_given = 1;
            args_info->domain_given = 1;
            if (args_info->MODE_group_counter && override)
              reset_group_MODE (args_info);
            args_info->MODE_group_counter += 1;
            break;
          }
          /* use Fixed-threshold SMO for structural SVM (shared slack).  */
          else if (strcmp (long_options[option_index].name, "fsmo") == 0)
          {
            if (local_args_info.fsmo_given)
              {
                fprintf (stderr, "%s: `--fsmo' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->fsmo_given && ! override)
              continue;
            local_args_info.fsmo_given = 1;
            args_info->fsmo_given = 1;
            if (args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter && override)
              reset_group_Parameter_Estimate_Method_for_structural_SVM (args_info);
            args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter += 1;
            break;
          }
          /* use FSMO + joint constraint (1-slack) using Gram matrix.  */
          else if (strcmp (long_options[option_index].name, "fsmo_joint") == 0)
          {
            if (local_args_info.fsmo_joint_given)
              {
                fprintf (stderr, "%s: `--fsmo_joint' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->fsmo_joint_given && ! override)
              continue;
            local_args_info.fsmo_joint_given = 1;
            args_info->fsmo_joint_given = 1;
            if (args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter && override)
              reset_group_Parameter_Estimate_Method_for_structural_SVM (args_info);
            args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter += 1;
            break;
          }
          /* use FSMO + joint constraint (1-slack) without Gram matrix (slow version).  */
          else if (strcmp (long_options[option_index].name, "fsmo_joint2") == 0)
          {
            if (local_args_info.fsmo_joint2_given)
              {
                fprintf (stderr, "%s: `--fsmo_joint2' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->fsmo_joint2_given && ! override)
              continue;
            local_args_info.fsmo_joint2_given = 1;
            args_info->fsmo_joint2_given = 1;
            if (args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter && override)
              reset_group_Parameter_Estimate_Method_for_structural_SVM (args_info);
            args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter += 1;
            break;
          }
          /* use Pegasos in primal optimization (random shuffled train_data) (default method).  */
          else if (strcmp (long_options[option_index].name, "pegasos") == 0)
          {
            if (local_args_info.pegasos_given)
              {
                fprintf (stderr, "%s: `--pegasos' option given more than once%s\n", argv[0], (additional_error ? additional_error : ""));
                goto failure;
              }
            if (args_info->pegasos_given && ! override)
              continue;
            local_args_info.pegasos_given = 1;
            args_info->pegasos_given = 1;
            if (args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter && override)
              reset_group_Parameter_Estimate_Method_for_structural_SVM (args_info);
            args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter += 1;
            break;
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */

  if (args_info->MODE_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group MODE were given. At most one is required.%s\n", argv[0], args_info->MODE_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  
  if (args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter > 1)
    {
      fprintf (stderr, "%s: %d options of group Parameter Estimate Method for structural SVM were given. At most one is required.%s\n", argv[0], args_info->Parameter_Estimate_Method_for_structural_SVM_group_counter, (additional_error ? additional_error : ""));
      error = 1;
    }
  



  cmdline_parser_release (&local_args_info);

  if ( error )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */

      i = optind;
      while (i < argc)
        if (argv[i++] == argv[0]) {
          found_prog_name = 1;
          break;
        }
      i = 0;

      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        if (argv[optind++] != argv[0])
          args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind-1]) ;
    }

  return 0;

failure:
  
  cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
